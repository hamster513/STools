"""
Репозиторий для работы с ExploitDB данными
"""
import asyncpg
import asyncio
from typing import Dict, List, Optional, Any
from datetime import datetime, date
from .base import DatabaseBase


class ExploitDBRepository(DatabaseBase):
    """Репозиторий для работы с ExploitDB данными"""

    async def insert_records(self, records: list):
        """Вставить записи ExploitDB"""
        if not records:
            print("No ExploitDB records to insert")
            return
        
        conn = await self.get_connection()
        try:
            # Очищаем старые записи
            await conn.execute("DELETE FROM vulnanalizer.exploitdb")
            
            # Вставляем новые записи батчами
            batch_size = 1000
            total_inserted = 0
            
            for i in range(0, len(records), batch_size):
                batch = records[i:i + batch_size]
                
                # Подготавливаем данные для вставки
                values = []
                for record in batch:
                    try:
                        exploit_id = record.get('id')
                        description = record.get('description', '').strip()
                        date_published_str = record.get('date_published', '')
                        author = record.get('author', '').strip()
                        platform = record.get('platform', '').strip()
                        exploit_type = record.get('type', '').strip()
                        port = record.get('port')
                        cves_str = record.get('codes', '')
                        verified = record.get('verified', False)
                        
                        # Проверяем обязательные поля
                        if not exploit_id or not description:
                            continue
                        
                        # Парсим дату
                        date_published = None
                        if date_published_str:
                            try:
                                date_published = datetime.strptime(date_published_str, '%Y-%m-%d').date()
                            except ValueError:
                                try:
                                    date_published = datetime.strptime(date_published_str, '%Y-%m-%d %H:%M:%S').date()
                                except ValueError:
                                    print(f"Invalid date format for exploit {exploit_id}: {date_published_str}")
                        
                        # Парсим порт
                        port_int = None
                        if port:
                            try:
                                port_int = int(port)
                            except (ValueError, TypeError):
                                pass
                        
                        # Парсим CVE коды
                        cves = []
                        if cves_str:
                            # Разделяем по запятой и очищаем
                            for cve in cves_str.split(','):
                                cve = cve.strip().upper()
                                if cve.startswith('CVE-'):
                                    cves.append(cve)
                        
                        # Обрабатываем verified
                        is_verified = bool(verified) if verified is not None else False
                        
                        values.append((
                            int(exploit_id),
                            description[:1000],  # Ограничиваем длину
                            date_published,
                            author[:200] if author else None,  # Ограничиваем длину
                            platform[:100] if platform else None,  # Ограничиваем длину
                            exploit_type[:100] if exploit_type else None,  # Ограничиваем длину
                            port_int,
                            cves,  # Массив CVE
                            is_verified,
                            datetime.now()
                        ))
                        
                    except Exception as e:
                        print(f"Error processing ExploitDB record: {e}")
                        continue
                
                if values:
                    # Массовая вставка
                    await conn.executemany("""
                        INSERT INTO vulnanalizer.exploitdb (id, description, date_published, author, platform, type, port, codes, verified, updated_at) 
                        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                        ON CONFLICT (id) DO UPDATE SET
                            description = EXCLUDED.description,
                            date_published = EXCLUDED.updated_at,
                            author = EXCLUDED.author,
                            platform = EXCLUDED.platform,
                            type = EXCLUDED.type,
                            port = EXCLUDED.port,
                            codes = EXCLUDED.codes,
                            verified = EXCLUDED.verified,
                            updated_at = EXCLUDED.updated_at
                    """, values)
                    
                    total_inserted += len(values)
                    print(f"Inserted {len(values)} ExploitDB records (batch {i//batch_size + 1})")
            
            print(f"Successfully inserted {total_inserted} ExploitDB records")
            
        except Exception as e:
            print(f"Error inserting ExploitDB records: {e}")
            raise
        finally:
            await self.release_connection(conn)

    async def count_records(self):
        """Подсчитать количество записей ExploitDB"""
        conn = await self.get_connection()
        try:
            row = await conn.fetchrow("SELECT COUNT(*) as cnt FROM vulnanalizer.exploitdb")
            return row['cnt'] if row else 0
        except Exception as e:
            print(f"Error counting ExploitDB records: {e}")
            return 0
        finally:
            await self.release_connection(conn)

    async def get_all_records(self):
        """Получить все записи ExploitDB"""
        conn = await self.get_connection()
        try:
            rows = await conn.fetch("""
                SELECT id, description, date_published, author, platform, type, port, cves, verified, updated_at 
                FROM vulnanalizer.exploitdb 
                ORDER BY date_published DESC
            """)
            return [dict(row) for row in rows]
        except Exception as e:
            print(f"Error getting ExploitDB records: {e}")
            return []
        finally:
            await self.release_connection(conn)

    async def get_by_cve(self, cve_id: str):
        """Получить эксплойты по CVE ID"""
        if not cve_id:
            return []
            
        conn = await self.get_connection()
        try:
            cve_upper = cve_id.upper()
            rows = await conn.fetch("""
                SELECT id, description, date_published, author, platform, type, port, codes, verified, updated_at
                FROM vulnanalizer.exploitdb 
                WHERE codes LIKE '%' || $1 || '%'
                ORDER BY date_published DESC
            """, cve_upper)
            
            results = []
            for row in rows:
                results.append({
                    'id': row['id'],
                    'description': row['description'],
                    'date_published': row['date_published'].isoformat() if row['date_published'] else None,
                    'author': row['author'],
                    'platform': row['platform'],
                    'type': row['type'],
                    'port': row['port'],
                    'cves': row['cves'],
                    'verified': row['verified'],
                    'updated_at': row['updated_at'].isoformat() if row['updated_at'] else None
                })
            
            return results
        except Exception as e:
            print(f"Error getting ExploitDB data for {cve_id}: {e}")
            return []
        finally:
            await self.release_connection(conn)

    def _get_latest_exploit_date(self, exploitdb_data):
        """Получить дату последнего эксплойта"""
        if not exploitdb_data:
            return None
        
        latest_date = None
        for exploit in exploitdb_data:
            date_str = exploit.get('date_published')
            if date_str:
                try:
                    exploit_date = datetime.strptime(date_str, '%Y-%m-%d').date()
                    if latest_date is None or exploit_date > latest_date:
                        latest_date = exploit_date
                except ValueError:
                    continue
        
        return latest_date

    async def clear(self):
        """Очистить все записи ExploitDB"""
        conn = await self.get_connection()
        try:
            await conn.execute("DELETE FROM vulnanalizer.exploitdb")
            print("ExploitDB data cleared")
        except Exception as e:
            print(f"Error clearing ExploitDB data: {e}")
            raise
        finally:
            await self.release_connection(conn)
    
    async def count_exploitdb_records(self):
        """Алиас для count_records (для обратной совместимости)"""
        return await self.count_records()

    async def insert_exploitdb_records(self, records: list):
        """Вставить записи ExploitDB с улучшенным управлением соединениями"""
        conn = None
        try:
            # Создаем отдельное соединение для массовой вставки
            conn = await asyncpg.connect(self.database_url)
            
            # Проверяем, что соединение активно
            await conn.execute("SELECT 1")
            
            # Получаем количество записей до вставки
            count_before = await conn.fetchval("SELECT COUNT(*) FROM vulnanalizer.exploitdb")
            print(f"Records in database before insert: {count_before}")
            
            inserted_count = 0
            updated_count = 0
            
            # Обрабатываем записи батчами для избежания проблем с соединением
            batch_size = 1000
            
            for i in range(0, len(records), batch_size):
                batch_records = records[i:i + batch_size]
                
                # Проверяем соединение перед каждым батчем
                try:
                    await conn.execute("SELECT 1")
                except Exception as e:
                    print(f"Connection lost, reconnecting... Error: {e}")
                    await conn.close()
                    conn = await asyncpg.connect(self.database_url)
                
                async with conn.transaction():
                    query = """
                        INSERT INTO vulnanalizer.exploitdb (exploit_id, file_path, description, date_published, author, type, platform, port, date_added, date_updated, verified, codes, tags, aliases, screenshot_url, application_url, source_url)
                        VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17)
                        ON CONFLICT (exploit_id) DO UPDATE SET 
                            file_path = $2, description = $3, date_published = $4, author = $5, type = $6, platform = $7, port = $8, date_added = $9, date_updated = $10, verified = $11, codes = $12, tags = $13, aliases = $14, screenshot_url = $15, application_url = $16, source_url = $17
                    """
                    
                    for rec in batch_records:
                        try:
                            # Проверяем, существует ли запись
                            existing = await conn.fetchval("SELECT exploit_id FROM vulnanalizer.exploitdb WHERE exploit_id = $1", rec['exploit_id'])
                            
                            await conn.execute(query, 
                                rec['exploit_id'], rec.get('file_path'), rec.get('description'), 
                                rec.get('date_published'), rec.get('author'), rec.get('type'), 
                                rec.get('platform'), rec.get('port'), rec.get('date_added'), 
                                rec.get('date_updated'), rec.get('verified', False), rec.get('codes'), 
                                rec.get('tags'), rec.get('aliases'), rec.get('screenshot_url'), 
                                rec.get('application_url'), rec.get('source_url'))
                            
                            if existing:
                                updated_count += 1
                            else:
                                inserted_count += 1
                                
                        except Exception as e:
                            print(f"Error inserting record {rec['exploit_id']}: {e}")
                            continue
                
                print(f"Processed batch {i//batch_size + 1}/{(len(records) + batch_size - 1)//batch_size}")
            
            # Получаем количество записей после вставки
            count_after = await conn.fetchval("SELECT COUNT(*) FROM vulnanalizer.exploitdb")
            print(f"Records in database after insert: {count_after}")
            print(f"New records inserted: {inserted_count}")
            print(f"Existing records updated: {updated_count}")
            print(f"Total records processed: {len(records)}")
            print(f"Net change in database: {count_after - count_before}")
            
        except Exception as e:
            print(f"Error in insert_exploitdb_records: {e}")
            raise e
        finally:
            if conn:
                try:
                    await conn.close()
                except Exception as e:
                    print(f"Error closing connection: {e}")

    async def get_exploitdb_by_cve(self, cve_id: str):
        """Получить данные ExploitDB по CVE ID"""
        conn = await self.get_connection()
        try:
            # Нормализуем CVE ID для поиска в разных форматах
            cve_normalized = cve_id.upper()
            cve_with_underscores = cve_normalized.replace('-', '_')
            cve_without_dashes = cve_normalized.replace('-', '')
            
            # Извлекаем год и номер из CVE для более гибкого поиска
            cve_parts = cve_normalized.split('-')
            if len(cve_parts) >= 3:
                cve_year = cve_parts[1]
                cve_number = cve_parts[2]
                cve_year_number = f"{cve_year}-{cve_number}"
                cve_year_underscore_number = f"{cve_year}_{cve_number}"
            else:
                cve_year_number = cve_normalized
                cve_year_underscore_number = cve_normalized
            
            # Ищем в поле aliases, tags, description, codes с разными форматами CVE
            query = """
                SELECT exploit_id, file_path, description, date_published, 
                       author, type, platform, port, date_added, date_updated, 
                       verified, codes, tags, aliases, screenshot_url, 
                       application_url, source_url
                FROM vulnanalizer.exploitdb 
                WHERE aliases ILIKE $1 
                   OR tags ILIKE $1 
                   OR description ILIKE $1
                   OR codes ILIKE $1
                   OR aliases ILIKE $2
                   OR tags ILIKE $2
                   OR description ILIKE $2
                   OR codes ILIKE $2
                   OR aliases ILIKE $3
                   OR tags ILIKE $3
                   OR description ILIKE $3
                   OR codes ILIKE $3
                   OR aliases ILIKE $4
                   OR tags ILIKE $4
                   OR description ILIKE $4
                   OR codes ILIKE $4
                   OR aliases ILIKE $5
                   OR tags ILIKE $5
                   OR description ILIKE $5
                   OR codes ILIKE $5
                ORDER BY date_published DESC
            """
            rows = await conn.fetch(query, 
                f'%{cve_normalized}%', 
                f'%{cve_with_underscores}%', 
                f'%{cve_without_dashes}%',
                f'%{cve_year_number}%',
                f'%{cve_year_underscore_number}%')
            
            results = []
            for row in rows:
                results.append({
                    'exploit_id': row['exploit_id'],
                    'file_path': row['file_path'],
                    'description': row['description'],
                    'date_published': row['date_published'].isoformat() if row['date_published'] else None,
                    'author': row['author'],
                    'type': row['type'],
                    'platform': row['platform'],
                    'port': row['port'],
                    'date_added': row['date_added'].isoformat() if row['date_added'] else None,
                    'date_updated': row['date_updated'].isoformat() if row['date_updated'] else None,
                    'verified': row['verified'],
                    'codes': row['codes'],
                    'tags': row['tags'],
                    'aliases': row['aliases'],
                    'screenshot_url': row['screenshot_url'],
                    'application_url': row['application_url'],
                    'source_url': row['source_url']
                })
            
            return results
        except Exception as e:
            print(f"Error getting ExploitDB data for {cve_id}: {e}")
            return []
        finally:
            await self.release_connection(conn)

    async def get_all_exploitdb_records(self):
        """Получить все записи ExploitDB"""
        conn = await self.get_connection()
        try:
            rows = await conn.fetch("SELECT exploit_id, description, date_published, verified, aliases, tags FROM vulnanalizer.exploitdb ORDER BY exploit_id")
            return [dict(row) for row in rows]
        except Exception as e:
            print(f"Error getting all exploitdb records: {e}")
            raise
        finally:
            await self.release_connection(conn)

    async def clear_exploitdb(self):
        """Очистка таблицы ExploitDB"""
        conn = await self.get_connection()
        try:
            query = "DELETE FROM vulnanalizer.exploitdb"
            await conn.execute(query)
            print("ExploitDB table cleared successfully")
        except Exception as e:
            print(f"Error clearing ExploitDB table: {e}")
            raise e
        finally:
            await self.release_connection(conn)
